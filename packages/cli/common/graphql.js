"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.graphql = void 0;
const fs_1 = __importDefault(require("fs"));
const util_1 = require("./util");
const cli_1 = require("@graphql-codegen/cli");
const graphql = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const core_dir = `${options.cwd}/packages/core`;
    const resolvers = [];
    for (const graphql_server of (0, util_1.getGraphqlRouterConfigs)(options.cwd)) {
        var { schema } = yield (0, util_1.getGraphqlModules)(graphql_server, { schema: true, resolvers: false });
        // if schema is empty
        if (!schema || schema == "" || schema.length == 0) {
            console.log(`skipping, empty schema for pack:${graphql_server.pack} name:${graphql_server.name}`);
            continue;
        }
        const generates = {};
        generates[graphql_server.typeDefPath] = {
            plugins: ['typescript', 'typescript-operations', 'typescript-resolvers', 'typed-document-node'],
            config: {
                typesPrefix: 'I',
                declarationKind: 'interface',
                scalars: {
                    Object: 'any',
                    DateTime: 'Date',
                    Packages: 'Packages',
                    ObjectId: 'MongooseTypes.ObjectId',
                },
                enumsAsTypes: true,
                skipTypename: true,
            }
        };
        if (graphql_server.genClient == true) {
            generates[graphql_server.clientPath] = {
                preset: 'client',
                presetConfig: {
                    gqlTagName: 'gql',
                    typesPrefix: 'I',
                    declarationKind: 'interface',
                    scalars: {
                        Object: 'any',
                        DateTime: 'any',
                        Packages: 'any',
                        ObjectId: 'any',
                    },
                    enumsAsTypes: true,
                    skipTypename: true,
                }
            };
        }
        // write schema to file
        const CodegenConfig = {
            errorsOnly: true,
            debug: true,
            verbose: false,
            schema,
            documents: graphql_server.documents,
            generates
        };
        try {
            // if graphql shema is empty
            if (!CodegenConfig.schema || CodegenConfig.schema == "")
                throw new Error('graphql schema is empty');
            // generate graphql code
            yield (0, cli_1.generate)(CodegenConfig, true);
            let file_result = fs_1.default.readFileSync(graphql_server.typeDefPath, 'utf8');
            file_result = `
                import { DeepRequired } from 'utility-types'
                import { Packages } from '@typestackapp/core'
                import type { Types as MongooseTypes } from 'mongoose'
    
                ${file_result}
    
                // additional types generated by build-graphql.js script!
                export type GraphqlResolvers = Record<IGraphqlMethod, Record<string, any>>
    
                type GraphqlResources<T extends GraphqlResolvers> = {
                    [K in IGraphqlMethod]?: {
                        [K2 in keyof T[K]]?: IAccessOptions  
                    } 
                }
    
                export type Resources<T> = GraphqlResources<DeepRequired<IResolvers<T>>>
            `;
            fs_1.default.writeFileSync(graphql_server.typeDefPath, file_result, 'utf8');
            // extract IResolvers type keys from file_result: 
            // export type IResolvers<ContextType = any> = {
            //   AccessDocument?: IAccessDocumentResolvers<ContextType>;
            //   AccessInput?: IAccessInputResolvers<ContextType>;
            // resolvers should be ["AccessDocument", "AccessInput", ...]
            const regex = /export type IResolvers<ContextType = any> = {([^}]+)}/;
            const match = file_result.match(regex);
            if (match) {
                const resolvers_str = match[1];
                const resolvers_regex = /([A-Za-z]+)\?:/g;
                let resolvers_match;
                while ((resolvers_match = resolvers_regex.exec(resolvers_str)) !== null) {
                    resolvers.push(resolvers_match[1]);
                }
            }
        }
        catch (error) {
            console.error(error);
            console.log(Object.assign(Object.assign({}, CodegenConfig), { schema: '...' }));
        }
    }
    try {
        // create codegen/graphql/reosolvers.json file
        const resolvers_output = `${core_dir}/codegen/graphql/resolvers.json`;
        // check if folder exists
        if (!fs_1.default.existsSync(`${core_dir}/codegen/graphql`))
            fs_1.default.mkdirSync(`${core_dir}/codegen/graphql`, { recursive: true });
        fs_1.default.writeFileSync(resolvers_output, JSON.stringify(resolvers, null, 2), 'utf8');
    }
    catch (error) {
        console.error(error);
    }
});
exports.graphql = graphql;
